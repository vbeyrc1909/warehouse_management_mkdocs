{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Warehouse Management For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. about.md ... # Other markdown pages, images and other files.","title":"Welcome to Warehouse Management"},{"location":"#welcome-to-warehouse-management","text":"For full documentation visit mkdocs.org .","title":"Welcome to Warehouse Management"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. about.md ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"google/","text":"Google Apps Script Google Apps Script is an extension by Google to allow automation and create programmable scripts. In our system, we have used Google Apps Scripts to take information from the Gazebo simulator in realtime and update a Google Spreadsheets with complete information if inventory and warehouse state. We developed a RoS IoT bridge by using ROS to publish the information on an MQTT topic, which was read by HiveMQ, our MQTT broker. Google Apps Scripts is then used to access the API of the HiveMQ topic and gain the information from ROS. Google Apps Script also serves as a JSON Endpoint for the HTML dashboard that we have prepared which is a website showing all this information in a user-friendly interface","title":"Google App Scripting"},{"location":"google/#google-apps-script","text":"Google Apps Script is an extension by Google to allow automation and create programmable scripts. In our system, we have used Google Apps Scripts to take information from the Gazebo simulator in realtime and update a Google Spreadsheets with complete information if inventory and warehouse state. We developed a RoS IoT bridge by using ROS to publish the information on an MQTT topic, which was read by HiveMQ, our MQTT broker. Google Apps Scripts is then used to access the API of the HiveMQ topic and gain the information from ROS. Google Apps Script also serves as a JSON Endpoint for the HTML dashboard that we have prepared which is a website showing all this information in a user-friendly interface","title":"Google Apps Script"},{"location":"hive/","text":"MQTT Protocol MQTT stands for Message Queue Telemetry Transport. It is a publish/subscribe, extremely simple and lightweight messaging protocol, designed for constrained devices and low-bandwidth, high-latency or unreliable networks. Let us look into this publisher and subscriber pattern which is analogous to a server-client communication. The publisher subscriber model allows MQTT clients to communicate one-to-one, one-to-many and many-to-one. MQTT Publisher: In a MQTT Protocol, the publisher acts as a server who is used to 'publish' messages or here, topics to the client side through a broker. MQTT Topics: MQTT Topic refers to an UTF-8 string that the broker uses to filter messages for each connected client. The topic consists of one or more levels. Each 'topic level' is separated by a forward slash which is known as a topic separator MQTT Broker: The MQTT broker is primarily responsible for receiving all messages, filtering the messages, decide who is interested in them and then publishing the message to all subscribed clients. There are various MQTT brokers available online which we will be looking into detail further MQTT Subscriber: The MQTT subscriber 'subscribes' to topic published on to the broker by the publisher. It acts as a client for receiving and generating a record of the messages published. To make sure of the 'Quality' of messages published by MQTT Publisher, we have a parameter called Quality of Service (QoS) QoS0: The publication is sent but there is no confirmation QoS1: This ensures that the message is sent atleast once but duplicates may be received QoS2: This is the most bandwidth consuming mode, but the most reliable since duplicates are controlled by making sure message is sent only once. HiveMQ It is clear from the previous lessons that MQTT is a client server publish/subscribe messaging transport protocol. Now the central communication point is the MQTT broker, it is responsible of dispatching all messages between the senders and the receivers. There are different online MQTT broker available for eg. Mosquitto, emqx.io, Flespi, HiveMQ, MoQiatto, Mosca etc. We will be working with HiveMQ. For more information refer official documentation of HiveMQ .","title":"Hive MQ"},{"location":"hive/#mqtt-protocol","text":"MQTT stands for Message Queue Telemetry Transport. It is a publish/subscribe, extremely simple and lightweight messaging protocol, designed for constrained devices and low-bandwidth, high-latency or unreliable networks. Let us look into this publisher and subscriber pattern which is analogous to a server-client communication. The publisher subscriber model allows MQTT clients to communicate one-to-one, one-to-many and many-to-one. MQTT Publisher: In a MQTT Protocol, the publisher acts as a server who is used to 'publish' messages or here, topics to the client side through a broker. MQTT Topics: MQTT Topic refers to an UTF-8 string that the broker uses to filter messages for each connected client. The topic consists of one or more levels. Each 'topic level' is separated by a forward slash which is known as a topic separator MQTT Broker: The MQTT broker is primarily responsible for receiving all messages, filtering the messages, decide who is interested in them and then publishing the message to all subscribed clients. There are various MQTT brokers available online which we will be looking into detail further MQTT Subscriber: The MQTT subscriber 'subscribes' to topic published on to the broker by the publisher. It acts as a client for receiving and generating a record of the messages published. To make sure of the 'Quality' of messages published by MQTT Publisher, we have a parameter called Quality of Service (QoS) QoS0: The publication is sent but there is no confirmation QoS1: This ensures that the message is sent atleast once but duplicates may be received QoS2: This is the most bandwidth consuming mode, but the most reliable since duplicates are controlled by making sure message is sent only once.","title":"MQTT Protocol"},{"location":"hive/#hivemq","text":"It is clear from the previous lessons that MQTT is a client server publish/subscribe messaging transport protocol. Now the central communication point is the MQTT broker, it is responsible of dispatching all messages between the senders and the receivers. There are different online MQTT broker available for eg. Mosquitto, emqx.io, Flespi, HiveMQ, MoQiatto, Mosca etc. We will be working with HiveMQ. For more information refer official documentation of HiveMQ .","title":"HiveMQ"},{"location":"implementation/","text":"Implementation In this task, we have implemented a completely autonomous Warehouse Management System that sorts packages based on incoming customer orders from different cities while updating them in real-time and notifying their order status. The entire warehouse has been simulated in a Gazebo environment with various manipulators and systems established as ROS nodes. To update the system in real-time, Google Apps Scripts has been utilized with a ROS node publishing information to an MQTT portal from whose API the information is taken and updated into Google Spreadsheets and an HTML webpage. The customer orders are simulated by colored boxes kept on a shelf. The boxes are of 3 colors, Red implying Medicine and High Priority, Yellow implying Food and Medium Priority and Green implying Clothes and Low Priority. The packages' colors are identified by a camera; as the packages are identified, the Inventory sheet of the Inventory Management Spreadsheet is updated using the ROS-IoT bridge. Nine orders are published on the MQTT Topic, from which information is obtained via the ROS-IoT Bridge. The UR5#1 Arm then processes these orders while prioritizing the packages based on their order to ensure the high-priority orders get processed as soon as possible. The UR5#1 arm represents the order dispatcher. It places the appropriate package on the Gazebo environment's conveyer belt, signifying the order has been dispatched. The moment this happens, the Orders Dispatched sheet of the Inventory Management Spreadsheet gets updated. It sends an email notification to the user. The conveyor belt then takes the package to UR5#2, which picks up the respective package and keeps it in a corresponding color bin. The moment this happens, the Orders Shipped sheet of the Warehouse Inventory Spreadsheet gets updated. It sends an email notification to the user. As the simulation proceeds, the Warehouse Management Dashboard is updated in real-time using a separate Dashboard sheet as a JSON endpoint. To publish information, we have utilized the MQTT or Message Queue Telemetry Transport protocol. The protocol has various roles like : Roles Publisher - A server who sends messages to various topics Topic - a UTF-8 string used to filter messages to clients consists of various levels. Broker - Responsible for receiving all messages and filtering them Subscriber - A client that receives the messages published We utilized the HiveMQ as an MQTT Broker. We have utilized Google Apps Script to automate and integrate our solution. Apps Script uses cloud-based scripting written in JavaScript, CSS, or HTML. Information is read from the API of the MQTT broker and is documented on the spreadsheet. With specific triggers, email notifications are sent appropriately. We have also created a Dashboard web page that shows the information about all orders on a world map while also tabulating the status of past and present orders and showing statistics of figures like delivery team etc. The spreadsheet also serves as a JSON endpoint for the Dashboard webpage.","title":"Implementation"},{"location":"implementation/#implementation","text":"In this task, we have implemented a completely autonomous Warehouse Management System that sorts packages based on incoming customer orders from different cities while updating them in real-time and notifying their order status. The entire warehouse has been simulated in a Gazebo environment with various manipulators and systems established as ROS nodes. To update the system in real-time, Google Apps Scripts has been utilized with a ROS node publishing information to an MQTT portal from whose API the information is taken and updated into Google Spreadsheets and an HTML webpage. The customer orders are simulated by colored boxes kept on a shelf. The boxes are of 3 colors, Red implying Medicine and High Priority, Yellow implying Food and Medium Priority and Green implying Clothes and Low Priority. The packages' colors are identified by a camera; as the packages are identified, the Inventory sheet of the Inventory Management Spreadsheet is updated using the ROS-IoT bridge. Nine orders are published on the MQTT Topic, from which information is obtained via the ROS-IoT Bridge. The UR5#1 Arm then processes these orders while prioritizing the packages based on their order to ensure the high-priority orders get processed as soon as possible. The UR5#1 arm represents the order dispatcher. It places the appropriate package on the Gazebo environment's conveyer belt, signifying the order has been dispatched. The moment this happens, the Orders Dispatched sheet of the Inventory Management Spreadsheet gets updated. It sends an email notification to the user. The conveyor belt then takes the package to UR5#2, which picks up the respective package and keeps it in a corresponding color bin. The moment this happens, the Orders Shipped sheet of the Warehouse Inventory Spreadsheet gets updated. It sends an email notification to the user. As the simulation proceeds, the Warehouse Management Dashboard is updated in real-time using a separate Dashboard sheet as a JSON endpoint. To publish information, we have utilized the MQTT or Message Queue Telemetry Transport protocol. The protocol has various roles like :","title":"Implementation"},{"location":"implementation/#roles","text":"Publisher - A server who sends messages to various topics Topic - a UTF-8 string used to filter messages to clients consists of various levels. Broker - Responsible for receiving all messages and filtering them Subscriber - A client that receives the messages published We utilized the HiveMQ as an MQTT Broker. We have utilized Google Apps Script to automate and integrate our solution. Apps Script uses cloud-based scripting written in JavaScript, CSS, or HTML. Information is read from the API of the MQTT broker and is documented on the spreadsheet. With specific triggers, email notifications are sent appropriately. We have also created a Dashboard web page that shows the information about all orders on a world map while also tabulating the status of past and present orders and showing statistics of figures like delivery team etc. The spreadsheet also serves as a JSON endpoint for the Dashboard webpage.","title":"Roles"},{"location":"intro/","text":"Welcome to Warehouse Management For full documentation visit mkdocs.org . Description We have implemented a warehouse management system utilizing Gazebo to simulate the autonomous package detection and sorting system. The information is updated in realtime to a webpage dashboard and kept track of in a Google Sheets with email notifications sent at every stage implemented via Google Script Editor. System Specifications OS : Ubuntu 18.04 Processor : Intel Core i5 RAM : 4GB/ 8GB ROS Version : ROS Melodic Python Version : Python 2.7 Prerequisites Ubuntu 18.04 Python 2.7 ROS Melodic and Move It! Google Apps Scripting Hive MQ Contact Us Mail us","title":"Home"},{"location":"intro/#welcome-to-warehouse-management","text":"For full documentation visit mkdocs.org .","title":"Welcome to Warehouse Management"},{"location":"intro/#description","text":"We have implemented a warehouse management system utilizing Gazebo to simulate the autonomous package detection and sorting system. The information is updated in realtime to a webpage dashboard and kept track of in a Google Sheets with email notifications sent at every stage implemented via Google Script Editor.","title":"Description"},{"location":"intro/#system-specifications","text":"OS : Ubuntu 18.04 Processor : Intel Core i5 RAM : 4GB/ 8GB ROS Version : ROS Melodic Python Version : Python 2.7","title":"System Specifications"},{"location":"intro/#prerequisites","text":"Ubuntu 18.04 Python 2.7 ROS Melodic and Move It! Google Apps Scripting Hive MQ","title":"Prerequisites"},{"location":"intro/#contact-us","text":"Mail us","title":"Contact Us"},{"location":"iot/","text":"IoT Python Script def iot_func_callback_sub(client, userdata, message): This is a callback function for MQTT Subscription messages, it decodes in the incoming string and prints the message received, the message topic, the message qos and the message retains flag. def mqtt_subscribe_thread_start(arg_callback_func, arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_qos): This function starts the mqtt subscription to a particular topic, it takes in its arguments a callback function which instructs it on what to do when a message is received as well as the broker information and the topic to subscribe to. def mqtt_publish(arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos): This function starts the mqtt publisher service onto a particular topic, it takes in its arguments the details of the broker which will handle the publishing and the mqtt topic/message to publish the information to. def http_publish(spread_sheet_id, data_dict): This function is used to push data to the Google Spreadsheet via using a Web App developed via Google Apps Script. It publishes the requisite information on the macro url with the sheet id and the parameters.","title":"IOT"},{"location":"iot/#iot-python-script","text":"","title":"IoT Python Script"},{"location":"iot/#def-iot_func_callback_subclient-userdata-message","text":"This is a callback function for MQTT Subscription messages, it decodes in the incoming string and prints the message received, the message topic, the message qos and the message retains flag.","title":"def iot_func_callback_sub(client, userdata, message):"},{"location":"iot/#def-mqtt_subscribe_thread_startarg_callback_func-arg_broker_url-arg_broker_port-arg_mqtt_topic-arg_mqtt_qos","text":"This function starts the mqtt subscription to a particular topic, it takes in its arguments a callback function which instructs it on what to do when a message is received as well as the broker information and the topic to subscribe to.","title":"def mqtt_subscribe_thread_start(arg_callback_func, arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_qos):"},{"location":"iot/#def-mqtt_publisharg_broker_url-arg_broker_port-arg_mqtt_topic-arg_mqtt_message-arg_mqtt_qos","text":"This function starts the mqtt publisher service onto a particular topic, it takes in its arguments the details of the broker which will handle the publishing and the mqtt topic/message to publish the information to.","title":"def mqtt_publish(arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos):"},{"location":"iot/#def-http_publishspread_sheet_id-data_dict","text":"This function is used to push data to the Google Spreadsheet via using a Web App developed via Google Apps Script. It publishes the requisite information on the macro url with the sheet id and the parameters.","title":"def http_publish(spread_sheet_id, data_dict):"},{"location":"python/","text":"Python 2.7 Installation steps Prerequisites sudo apt-get update sudo apt-get install build-essential checkinstall sudo apt-get install libreadline-gplv2-dev libncursesw5-dev libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev Download Python 2.7 cd /usr/src wget https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tgz sudo tar xzf Python-2.7.18.tgz Compile Python Source cd Python-2.7.18 sudo ./configure --enable-optimizations sudo make altinstall Check the Version python2.7 -V","title":"Python 2.7"},{"location":"python/#python-27","text":"","title":"Python 2.7"},{"location":"python/#installation-steps","text":"","title":"Installation steps"},{"location":"python/#prerequisites","text":"sudo apt-get update sudo apt-get install build-essential checkinstall sudo apt-get install libreadline-gplv2-dev libncursesw5-dev libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev","title":"Prerequisites"},{"location":"python/#download-python-27","text":"cd /usr/src wget https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tgz sudo tar xzf Python-2.7.18.tgz","title":"Download Python 2.7"},{"location":"python/#compile-python-source","text":"cd Python-2.7.18 sudo ./configure --enable-optimizations sudo make altinstall","title":"Compile Python Source"},{"location":"python/#check-the-version","text":"python2.7 -V","title":"Check the Version"},{"location":"ros/","text":"ROS Melodic How To? Installation Steps Setup your computer to accept software from packages.ros.org. sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Set up your keys. sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 Make sure your Debian package index is up-to-date. sudo apt update Installing the ROS recommended configuration. sudo apt install ros-melodic-desktop-full Configuration Steps Adding environment variables: To Automatically add ROS environment variables to your bash session every time a new shell (terminal) is launched, enter the following commands (this step is similar as adding environmental variable in windows): echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc source ~/.bashrc Initialize rosdep: Before you can use many ROS tools, you will need to initialize rosdep. rosdep enables you to easily install system dependencies for the source you want to compile and is required to run some core components in ROS. sudo apt install python-rosdep sudo rosdep init rosdep update More packages to install - Catkin Tools sudo apt-get install ros-melodic-catkin python-catkin-tools std_msg package sudo apt install ros-melodic-std-msgs turtlesim sudo apt-get install ros-melodic-ros-tutorials Install Move It! To install this cd into your ROS Workspace's src folder and then enter the following command git clone https://github.com/e-yantra-r3/vb_simulation_pkgs.git Once the repo is cloned, build your workspace and source the setup.bash of your workspace. To check if everything is installed properly enter the following command roslaunch pkg_vb_sim task5_simulation.launch","title":"ROS Melodic and Move It!"},{"location":"ros/#ros-melodic","text":"","title":"ROS Melodic"},{"location":"ros/#how-to","text":"","title":"How To?"},{"location":"ros/#installation-steps","text":"Setup your computer to accept software from packages.ros.org. sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Set up your keys. sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 Make sure your Debian package index is up-to-date. sudo apt update Installing the ROS recommended configuration. sudo apt install ros-melodic-desktop-full","title":"Installation Steps"},{"location":"ros/#configuration-steps","text":"Adding environment variables: To Automatically add ROS environment variables to your bash session every time a new shell (terminal) is launched, enter the following commands (this step is similar as adding environmental variable in windows): echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc source ~/.bashrc Initialize rosdep: Before you can use many ROS tools, you will need to initialize rosdep. rosdep enables you to easily install system dependencies for the source you want to compile and is required to run some core components in ROS. sudo apt install python-rosdep sudo rosdep init rosdep update","title":"Configuration Steps"},{"location":"ros/#more-packages-to-install-catkin-tools","text":"sudo apt-get install ros-melodic-catkin python-catkin-tools std_msg package sudo apt install ros-melodic-std-msgs turtlesim sudo apt-get install ros-melodic-ros-tutorials Install Move It! To install this cd into your ROS Workspace's src folder and then enter the following command git clone https://github.com/e-yantra-r3/vb_simulation_pkgs.git Once the repo is cloned, build your workspace and source the setup.bash of your workspace. To check if everything is installed properly enter the following command roslaunch pkg_vb_sim task5_simulation.launch","title":"More packages to install - Catkin Tools"},{"location":"ros_iot/","text":"IotRosBridgeActionServer: def init (self): This function is used to initialize the action server. All the IoT Configuration data is read and stored from the Parameter Server. Incoming messages from the MQTT Subscription are then published on the ROS Topic /ros_iot_bridge/mqtt/sub and then other nodes can subscribe to this ROS Topic to get messages from MQTT. def mqtt_sub_callback(self, client, userdata, message): This function is a callback function for the MQTT Subscription, whenever there is a message from MQTT, this function will be called and will store the incoming string in a variable and print it out on the respective topic. def on_goal(self, goal_handle): This function is called whenever the Action Server receives a Goal, it validates the incoming goal parameters and starts a new thread to process the new goal from the client. def process_goal(self, goal_handle): This function serves as a separate thread to process the goal from the client. Based on whether the incoming goal protocol is MQTT or http it appropriately processes the string and logs the information. def on_cancel(self, goal_handle): This function is called whenever a request to cancel the goal is sent to the action server. def main(): This function serves as the main function to initialize the ros iot bridge node. It has dependencies on all the aforementioned functions.","title":"ROS IOT Bridge"},{"location":"ros_iot/#iotrosbridgeactionserver","text":"","title":"IotRosBridgeActionServer:"},{"location":"ros_iot/#def-initself","text":"This function is used to initialize the action server. All the IoT Configuration data is read and stored from the Parameter Server. Incoming messages from the MQTT Subscription are then published on the ROS Topic /ros_iot_bridge/mqtt/sub and then other nodes can subscribe to this ROS Topic to get messages from MQTT.","title":"def init(self):"},{"location":"ros_iot/#def-mqtt_sub_callbackself-client-userdata-message","text":"This function is a callback function for the MQTT Subscription, whenever there is a message from MQTT, this function will be called and will store the incoming string in a variable and print it out on the respective topic.","title":"def mqtt_sub_callback(self, client, userdata, message):"},{"location":"ros_iot/#def-on_goalself-goal_handle","text":"This function is called whenever the Action Server receives a Goal, it validates the incoming goal parameters and starts a new thread to process the new goal from the client.","title":"def on_goal(self, goal_handle):"},{"location":"ros_iot/#def-process_goalself-goal_handle","text":"This function serves as a separate thread to process the goal from the client. Based on whether the incoming goal protocol is MQTT or http it appropriately processes the string and logs the information.","title":"def process_goal(self, goal_handle):"},{"location":"ros_iot/#def-on_cancelself-goal_handle","text":"This function is called whenever a request to cancel the goal is sent to the action server.","title":"def on_cancel(self, goal_handle):"},{"location":"ros_iot/#def-main","text":"This function serves as the main function to initialize the ros iot bridge node. It has dependencies on all the aforementioned functions.","title":"def main():"},{"location":"ubuntu/","text":"You can install the Debian image from here","title":"Ubuntu 18.04"},{"location":"ur5_1/","text":"UR5_1 Python Script We start by sending orders to the action server We define an action client class for IoT Ros Bridge Class IotRosBridgeActionClient : def init (self): actionlib.Actionclient initializes the Action Client by using a custom message file called msgRosIotAction which is used by ROS actions internally with the name \u2018action_ros_iot.\u2019 A dictionary is initialized to store all the orders/goal values In order to publish on a topic to the client-side via MQTT broker, we store the MQTT Topic in a variable _config_mqtt_pub_topic according to the format specified in the config_pyiot yaml file The next line waits for the action server to initiate/start so that we can send goals to the MQTT Topic def on_transition(self, goal_handle): This function will be called when there is a change of state in the Action Client State Machine It uses a parameter called goal_handle which is generated in another function called send_goal Further, we check the goal\u2019s communication state which monitors the State Machine of the Client which is different from Server's If the communication state of the goal is 2 then the client is said to be active, if it is 3 then it\u2019ll wait for the result & when it is 7 then the work is done. When the goal is done get the result produced from the action server. If result.flag_success is true then a message saying the Goal successfully completed is printed on the screen otherwise Goal will be failed. def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message) This function is used to send goals to the Action Server Initially, we create a Goal message object using msgRosIotGoal which is a custom message class to store goal message. We initialize the variables according to action definition. Class Ur5Moveit(): The constructor function of Ur5moveit defines all the properties of Ur5_1 arm. It defines a service variable to call activate_vacuum_gripper for ur5_1. def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name): This function lets the ur5_1 use the saved path trajectory and allows the ur5_1 arm to play these trajectories stored as YAML files. def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts=0): This function works similar to move_it_play_path_from_file but causes the ur5 arms to run a number of times. It calls move_it_play_path_from_file a number of times till the flag_success variable returns False. def attach_box(self, timeout=4): Attach box functions activates the activate_vacuum_gripper service and grips the box to the ur5_1 arm. Detach_box function is called to deactivate the vacuum gripper & detach the box from the ur5_1 and release it on the Conveyer Belt. rospy.init_node('node_move_ur5_1', anonymous=True) We initialize objects for the classes defined in the script. Pack_details denotes the name od the red, yellow and green packages respectively. rospy.Publisher declares that the ros node is publishing to the topic - eyrc/vb/dispatched using message type string def receive_order(order): This function receives the incoming orders and reads the order details from order.message. It then sends the goal to the iot_ros_client to publish it on the google sheet named Incoming Orders. Ur5 then calls the function to go to the shelf to pick the desired package according to its priority, attaches the box, places the box on the conveyer belt and then detached the box from the vacuum-gripper. As soon as ur5_1 places the box on the conveyer belt it sends the goal message to iot_ros_client to publish it on the google sheet named OrdersDispatched. Further, it stores the colours of the boxes according to the name of the item in an array pack_details.","title":"UR5_1"},{"location":"ur5_1/#ur5_1-python-script","text":"We start by sending orders to the action server We define an action client class for IoT Ros Bridge Class IotRosBridgeActionClient :","title":"UR5_1 Python Script"},{"location":"ur5_1/#def-initself","text":"actionlib.Actionclient initializes the Action Client by using a custom message file called msgRosIotAction which is used by ROS actions internally with the name \u2018action_ros_iot.\u2019 A dictionary is initialized to store all the orders/goal values In order to publish on a topic to the client-side via MQTT broker, we store the MQTT Topic in a variable _config_mqtt_pub_topic according to the format specified in the config_pyiot yaml file The next line waits for the action server to initiate/start so that we can send goals to the MQTT Topic","title":"def init(self):"},{"location":"ur5_1/#def-on_transitionself-goal_handle","text":"This function will be called when there is a change of state in the Action Client State Machine It uses a parameter called goal_handle which is generated in another function called send_goal Further, we check the goal\u2019s communication state which monitors the State Machine of the Client which is different from Server's If the communication state of the goal is 2 then the client is said to be active, if it is 3 then it\u2019ll wait for the result & when it is 7 then the work is done. When the goal is done get the result produced from the action server. If result.flag_success is true then a message saying the Goal successfully completed is printed on the screen otherwise Goal will be failed.","title":"def on_transition(self, goal_handle):"},{"location":"ur5_1/#def-send_goalself-arg_protocol-arg_mode-arg_topic-arg_message","text":"This function is used to send goals to the Action Server Initially, we create a Goal message object using msgRosIotGoal which is a custom message class to store goal message. We initialize the variables according to action definition.","title":"def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message)"},{"location":"ur5_1/#class-ur5moveit","text":"The constructor function of Ur5moveit defines all the properties of Ur5_1 arm. It defines a service variable to call activate_vacuum_gripper for ur5_1.","title":"Class Ur5Moveit():"},{"location":"ur5_1/#def-moveit_play_planned_path_from_fileself-arg_file_path-arg_file_name","text":"This function lets the ur5_1 use the saved path trajectory and allows the ur5_1 arm to play these trajectories stored as YAML files.","title":"def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name):"},{"location":"ur5_1/#def-moveit_hard_play_planned_path_from_fileself-arg_file_path-arg_file_name-arg_max_attempts0","text":"This function works similar to move_it_play_path_from_file but causes the ur5 arms to run a number of times. It calls move_it_play_path_from_file a number of times till the flag_success variable returns False.","title":"def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts=0):"},{"location":"ur5_1/#def-attach_boxself-timeout4","text":"Attach box functions activates the activate_vacuum_gripper service and grips the box to the ur5_1 arm. Detach_box function is called to deactivate the vacuum gripper & detach the box from the ur5_1 and release it on the Conveyer Belt.","title":"def attach_box(self, timeout=4):"},{"location":"ur5_1/#rospyinit_nodenode_move_ur5_1-anonymoustrue","text":"We initialize objects for the classes defined in the script. Pack_details denotes the name od the red, yellow and green packages respectively. rospy.Publisher declares that the ros node is publishing to the topic - eyrc/vb/dispatched using message type string","title":"rospy.init_node('node_move_ur5_1', anonymous=True)"},{"location":"ur5_1/#def-receive_orderorder","text":"This function receives the incoming orders and reads the order details from order.message. It then sends the goal to the iot_ros_client to publish it on the google sheet named Incoming Orders. Ur5 then calls the function to go to the shelf to pick the desired package according to its priority, attaches the box, places the box on the conveyer belt and then detached the box from the vacuum-gripper. As soon as ur5_1 places the box on the conveyer belt it sends the goal message to iot_ros_client to publish it on the google sheet named OrdersDispatched. Further, it stores the colours of the boxes according to the name of the item in an array pack_details.","title":"def receive_order(order):"},{"location":"ur5_2/","text":"UR5_2 Python Script rospy.init_node('node_move_ur5_2', anonymous=True) As part of the init_node() call, the default name of node is called. Names must be unique in ROS. The anonymous name tag is added so that we don\u2019t have to take care of using unique names for the node. In this function, the length of the package, the width of the vacuum gripper and the colours of packages are defined. Class Camera: self.bridge = CvBridge() CvBridge is a ROS library that provides an interface between ROS and OpenCV. First, the publisher gets created. Further during initialisation the topic gets subscribed (using the callback method of the newly created object). def callback(self,data): cv_image = self.bridge.imgmsg_to_cv2(data, \"bgr8\") (rows,cols,channels) = cv_image.shape First, the subscriber image is converted into an OpenCV image and on its success, its shape is accessed. The image is then converted from BGR to GRAY. Adaptive thresholding is the method where the threshold value is calculated for smaller regions and therefore, there will be different threshold values for different regions. The threshold value is a gaussian-weighted sum of the neighborhood values minus the constant C and the image is then converted back to BGR format. If the decoded value is less than 12, it returns null. Then it detects the boxes as medicine, food and clothes on the basis of decoded image. If this is run successfully for all the packages, it gives a message \u201cPackages Identified\u201d on ROS. The rate is fixed at 10Hz and then the value for colour is published for each package in the 1st row and then it is stored in Inventory along with its colour, cost, and quantity details self._computed_plan = '' This Attribute to store computed trajectory by the planner self._curr_state = self._robot.get_current_state() Current State of the Robot is needed to add box to planning scene rp = rospkg.RosPack() This saves the trajectory of the path planned so as to speed up the process. def set_joint_angles(self, arg_list_joint_angles): TDefines the angles that are set for the ur5_2 to pick the package and to place it into the bin def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts=1): Saves the angles for the further blocks to speed up the process def go_to_pose(self, arg_pose): Decides the destination for the pose def hard_go_to_pose(self, arg_pose, arg_max_attempts=5): This function saves the decided destination of pose for future packages. def ee_cartesian_translation(self, trans_x, trans_y, trans_z): This function computes a cartesian path connecting the initial pose to the final pose and makes the arm follow the computed path def attach_box(self): def detach_box(self): These functions return if the box was attached and detached successfully. def conveyor_belt(power): Sets the power source for the conveyor belt def pick_and_place(box): This function first notes the position at which the box would have to be picked up from and then attaches to it and after distinguishing it, it is placed in one of the boxes according to its color. When the camera sees the package, it sets the speed of the conveyor belt to 0 and after dropping it in the bin, restarts the conveyor belt to receive the next package","title":"UR5_2"},{"location":"ur5_2/#ur5_2-python-script","text":"","title":"UR5_2 Python Script"},{"location":"ur5_2/#rospyinit_nodenode_move_ur5_2-anonymoustrue","text":"As part of the init_node() call, the default name of node is called. Names must be unique in ROS. The anonymous name tag is added so that we don\u2019t have to take care of using unique names for the node. In this function, the length of the package, the width of the vacuum gripper and the colours of packages are defined.","title":"rospy.init_node('node_move_ur5_2', anonymous=True)"},{"location":"ur5_2/#class-camera","text":"","title":"Class Camera:"},{"location":"ur5_2/#selfbridge-cvbridge","text":"CvBridge is a ROS library that provides an interface between ROS and OpenCV. First, the publisher gets created. Further during initialisation the topic gets subscribed (using the callback method of the newly created object).","title":"self.bridge = CvBridge()"},{"location":"ur5_2/#def-callbackselfdata","text":"","title":"def callback(self,data):"},{"location":"ur5_2/#cv_image-selfbridgeimgmsg_to_cv2data-bgr8","text":"","title":"cv_image = self.bridge.imgmsg_to_cv2(data, \"bgr8\")"},{"location":"ur5_2/#rowscolschannels-cv_imageshape","text":"First, the subscriber image is converted into an OpenCV image and on its success, its shape is accessed. The image is then converted from BGR to GRAY. Adaptive thresholding is the method where the threshold value is calculated for smaller regions and therefore, there will be different threshold values for different regions. The threshold value is a gaussian-weighted sum of the neighborhood values minus the constant C and the image is then converted back to BGR format. If the decoded value is less than 12, it returns null. Then it detects the boxes as medicine, food and clothes on the basis of decoded image. If this is run successfully for all the packages, it gives a message \u201cPackages Identified\u201d on ROS. The rate is fixed at 10Hz and then the value for colour is published for each package in the 1st row and then it is stored in Inventory along with its colour, cost, and quantity details","title":"(rows,cols,channels) = cv_image.shape"},{"location":"ur5_2/#self_computed_plan","text":"This Attribute to store computed trajectory by the planner","title":"self._computed_plan = ''"},{"location":"ur5_2/#self_curr_state-self_robotget_current_state","text":"Current State of the Robot is needed to add box to planning scene","title":"self._curr_state = self._robot.get_current_state()"},{"location":"ur5_2/#rp-rospkgrospack","text":"This saves the trajectory of the path planned so as to speed up the process.","title":"rp = rospkg.RosPack()"},{"location":"ur5_2/#def-set_joint_anglesself-arg_list_joint_angles","text":"TDefines the angles that are set for the ur5_2 to pick the package and to place it into the bin","title":"def set_joint_angles(self, arg_list_joint_angles):"},{"location":"ur5_2/#def-hard_set_joint_anglesself-arg_list_joint_angles-arg_max_attempts1","text":"Saves the angles for the further blocks to speed up the process","title":"def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts=1):"},{"location":"ur5_2/#def-go_to_poseself-arg_pose","text":"Decides the destination for the pose","title":"def go_to_pose(self, arg_pose):"},{"location":"ur5_2/#def-hard_go_to_poseself-arg_pose-arg_max_attempts5","text":"This function saves the decided destination of pose for future packages.","title":"def hard_go_to_pose(self, arg_pose, arg_max_attempts=5):"},{"location":"ur5_2/#def-ee_cartesian_translationself-trans_x-trans_y-trans_z","text":"This function computes a cartesian path connecting the initial pose to the final pose and makes the arm follow the computed path","title":"def ee_cartesian_translation(self, trans_x, trans_y, trans_z):"},{"location":"ur5_2/#def-attach_boxself","text":"","title":"def attach_box(self):"},{"location":"ur5_2/#def-detach_boxself","text":"These functions return if the box was attached and detached successfully.","title":"def detach_box(self):"},{"location":"ur5_2/#def-conveyor_beltpower","text":"Sets the power source for the conveyor belt","title":"def conveyor_belt(power):"},{"location":"ur5_2/#def-pick_and_placebox","text":"This function first notes the position at which the box would have to be picked up from and then attaches to it and after distinguishing it, it is placed in one of the boxes according to its color. When the camera sees the package, it sets the speed of the conveyor belt to 0 and after dropping it in the bin, restarts the conveyor belt to receive the next package","title":"def pick_and_place(box):"}]}